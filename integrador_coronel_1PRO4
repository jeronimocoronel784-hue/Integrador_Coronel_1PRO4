#!/usr/bin/env python3
"""

"""
import csv
import os
import sys
from typing import List, Dict, Tuple

CSV_FILE = "paises.csv"
CSV_HEADERS = ["nombre", "poblacion", "superficie", "continente"]

# ---------------------- Mensajes (texto plano) ---------------------- #
def msg_error(text: str) -> None:
    print("ERROR: " + text)

def msg_warning(text: str) -> None:
    print("ADVERTENCIA: " + text)

def msg_success(text: str) -> None:
    print("ÉXITO: " + text)

def msg_info(text: str) -> None:
    print("INFO: " + text)

# ---------------------- CSV de ejemplo ampliado ---------------------- #

def crear_csv_ejemplo(path: str = CSV_FILE) -> None:
    """
    Crea un CSV de ejemplo con 18 países de distintos continentes.
    Descomentar la llamada en main() para generar el archivo inicial.
    """
    ejemplo = [
        {"nombre": "Argentina", "poblacion": "45376763", "superficie": "2780400", "continente": "América"},
        {"nombre": "Brasil",    "poblacion": "213993437", "superficie": "8515767", "continente": "América"},
        {"nombre": "Mexico",    "poblacion": "128932753", "superficie": "1964375", "continente": "América"},
        {"nombre": "Estados Unidos", "poblacion": "331002651", "superficie": "9833520", "continente": "América"},
        {"nombre": "Canadá",    "poblacion": "37742154", "superficie": "9984670", "continente": "América"},
        {"nombre": "Japón",     "poblacion": "125800000", "superficie": "377975", "continente": "Asia"},
        {"nombre": "China",     "poblacion": "1393000000", "superficie": "9596961", "continente": "Asia"},
        {"nombre": "India",     "poblacion": "1380004385", "superficie": "3287263", "continente": "Asia"},
        {"nombre": "Alemania",  "poblacion": "83149300", "superficie": "357022", "continente": "Europa"},
        {"nombre": "Francia",   "poblacion": "65273511", "superficie": "643801", "continente": "Europa"},
        {"nombre": "España",    "poblacion": "46754778", "superficie": "505990", "continente": "Europa"},
        {"nombre": "Nigeria",   "poblacion": "206139589", "superficie": "923768", "continente": "África"},
        {"nombre": "Egipto",    "poblacion": "102334404", "superficie": "1010408", "continente": "África"},
        {"nombre": "Sudáfrica", "poblacion": "59308690", "superficie": "1221037", "continente": "África"},
        {"nombre": "Australia", "poblacion": "25499884", "superficie": "7692024", "continente": "Oceanía"},
        {"nombre": "Nueva Zelanda", "poblacion": "4822233", "superficie": "268838", "continente": "Oceanía"},
        {"nombre": "Islandia",  "poblacion": "341243", "superficie": "103000", "continente": "Europa"},
        {"nombre": "Chile",     "poblacion": "19116209", "superficie": "756102", "continente": "América"}
    ]
    try:
        with open(path, mode="w", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=CSV_HEADERS)
            writer.writeheader()
            for row in ejemplo:
                writer.writerow(row)
        msg_success(f"CSV de ejemplo creado en '{path}'.")
    except PermissionError:
        msg_error(f"No se tienen permisos para escribir en '{path}'. Ejecutar con permisos adecuados.")
    except Exception as e:
        msg_error(f"Error creando CSV de ejemplo: {e}")

# ---------------------- Lectura y escritura CSV ---------------------- #

def load_paises(path: str = CSV_FILE) -> List[Dict]:
    """
    Lee el CSV y devuelve una lista de diccionarios validando tipos.
    Maneja encabezados faltantes y filas mal formateadas.
    """
    paises = []
    if not os.path.exists(path):
        msg_warning(f"Archivo '{path}' no encontrado. Iniciando con lista vacía.")
        return paises

    try:
        with open(path, mode="r", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            if reader.fieldnames is None:
                msg_error(f"El archivo '{path}' no contiene encabezados CSV válidos.")
                return paises
            headers = [h.strip().lower() for h in reader.fieldnames]
            missing = [h for h in CSV_HEADERS if h not in headers]
            if missing:
                msg_warning(f"Encabezados faltantes en CSV: {missing}. Se intentará leer las columnas presentes.")
            for i, row in enumerate(reader, start=2):
                try:
                    nombre = (row.get("nombre") or "").strip()
                    poblacion_raw = (row.get("poblacion") or "").strip()
                    superficie_raw = (row.get("superficie") or "").strip()
                    continente = (row.get("continente") or "").strip()
                    if not nombre:
                        raise ValueError("Nombre vacío")
                    poblacion = int(poblacion_raw.replace(",", ""))
                    superficie = int(superficie_raw.replace(",", ""))
                    if poblacion < 0 or superficie < 0:
                        raise ValueError("Valores numéricos negativos")
                    paises.append({
                        "nombre": nombre,
                        "poblacion": poblacion,
                        "superficie": superficie,
                        "continente": continente or "Sin especificar"
                    })
                except ValueError as ve:
                    msg_warning(f"Fila {i}: formato inválido -> {ve}. Fila omitida.")
                except Exception as e:
                    msg_warning(f"Fila {i}: error al procesar -> {e}. Fila omitida.")
    except FileNotFoundError:
        msg_error(f"No se encontró el archivo '{path}'.")
    except PermissionError:
        msg_error(f"No se tienen permisos para leer '{path}'.")
    except Exception as e:
        msg_error(f"Error leyendo '{path}': {e}")
    return paises

def save_paises(paises: List[Dict], path: str = CSV_FILE) -> bool:
    """
    Guarda la lista de paises en el CSV. Retorna True si exito.
    """
    try:
        with open(path, mode="w", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=CSV_HEADERS)
            writer.writeheader()
            for p in paises:
                writer.writerow({
                    "nombre": p["nombre"],
                    "poblacion": str(p["poblacion"]),
                    "superficie": str(p["superficie"]),
                    "continente": p["continente"]
                })
        return True
    except PermissionError:
        msg_error(f"No se tienen permisos para escribir en '{path}'.")
        return False
    except Exception as e:
        msg_error(f"Error guardando en '{path}': {e}")
        return False

# ---------------------- Validaciones y entradas ---------------------- #

def validar_entero(text: str) -> Tuple[bool, int]:
    """
    Valida que text sea un entero no negativo. Retorna (ok, valor).
    """
    try:
        if text is None or text == "":
            return False, 0
        val = int(str(text).replace(",", "").strip())
        if val < 0:
            return False, 0
        return True, val
    except Exception:
        return False, 0

def pedir_entero(prompt: str) -> int:
    """
    Pide un entero no negativo hasta que el usuario ingrese un valor válido.
    """
    while True:
        entrada = input(prompt).strip()
        ok, val = validar_entero(entrada)
        if ok:
            return val
        msg_error("Entrada inválida. Ingrese un número entero no negativo. Ej: 123456")

def pedir_texto_no_vacio(prompt: str, allow_digits: bool = True) -> str:
    """
    Pide una cadena no vacía; si allow_digits=False, prohíbe entradas puramente numéricas.
    """
    while True:
        txt = input(prompt).strip()
        if not txt:
            msg_error("No puede quedar vacío. Intente nuevamente.")
            continue
        if not allow_digits and txt.isdigit():
            msg_error("Entrada inválida: no se permiten solo números en este campo.")
            continue
        return txt

# ---------------------- Presentacion y utilidades ---------------------- #

def mostrar_menu() -> None:
    print("\n" + "="*70)
    print("      GESTIÓN DE PAÍSES - Menú principal".center(70))
    print("="*70)
    print("1) Buscar país (coincidencia parcial o exacta)")
    print("2) Filtrar países")
    print("3) Ordenar países")
    print("4) Mostrar estadísticas")
    print("5) Agregar país")
    print("6) Editar país")
    print("7) Guardar y salir")
    print("8) Salir sin guardar")
    print("9) Crear CSV de ejemplo (si no existe)")
    print("="*70)

def imprimir_paises(paises: List[Dict]) -> None:
    if not paises:
        msg_info("No hay países para mostrar.")
        return
    print(f"\n{'Nombre':<25} {'Población':>12} {'Superficie':>12} {'Continente':>15}")
    print("-"*70)
    for p in paises:
        print(f"{p['nombre']:<25} {p['poblacion']:>12,} {p['superficie']:>12,} {p['continente']:>15}")
    print(f"\nTotal: {len(paises)} país(es).")

# ---------------------- Funcionalidades ---------------------- #

def buscar_pais(paises: List[Dict]) -> None:
    termino = pedir_texto_no_vacio("Ingrese el nombre o parte del nombre a buscar: ")
    termino_lower = termino.lower()
    # Búsqueda lineal con coincidencia parcial (O(n))
    encontrados = [p for p in paises if termino_lower in p["nombre"].lower()]
    if not encontrados:
        msg_warning("No se encontraron países con ese término.")
    else:
        imprimir_paises(encontrados)

def filtrar_por_continente(paises: List[Dict]) -> None:
    continente = pedir_texto_no_vacio("Ingrese el continente (ej. América, Europa, Asia): ", allow_digits=False)
    encontrados = [p for p in paises if p["continente"].lower() == continente.lower()]
    if not encontrados:
        msg_warning(f"No se encontraron países en el continente '{continente}'.")
    else:
        imprimir_paises(encontrados)

def pedir_rango_entero(campo: str) -> Tuple[int, int]:
    msg_info(f"Ingrese el rango para {campo}.")
    minimo = pedir_entero(f"  Mínimo {campo}: ")
    maximo = pedir_entero(f"  Máximo {campo}: ")
    if maximo < minimo:
        msg_warning("El máximo es menor que el mínimo; se intercambiarán los valores.")
        minimo, maximo = maximo, minimo
    return minimo, maximo

def filtrar_por_rango(paises: List[Dict], campo: str) -> None:
    if campo not in ("poblacion", "superficie"):
        msg_error("Campo de filtro inválido.")
        return
    minimo, maximo = pedir_rango_entero(campo)
    encontrados = [p for p in paises if minimo <= p[campo] <= maximo]
    if not encontrados:
        msg_warning(f"No se encontraron países con {campo} entre {minimo} y {maximo}.")
    else:
        imprimir_paises(encontrados)

def menu_filtrar(paises: List[Dict]) -> None:
    while True:
        print("\n--- Filtrar países ---")
        print("1) Por continente")
        print("2) Por rango de población")
        print("3) Por rango de superficie")
        print("4) Volver al menú principal")
        opcion = input("Opción: ").strip()
        if opcion == "1":
            filtrar_por_continente(paises)
        elif opcion == "2":
            filtrar_por_rango(paises, "poblacion")
        elif opcion == "3":
            filtrar_por_rango(paises, "superficie")
        elif opcion == "4":
            break
        else:
            msg_error("Opción inválida. Intente nuevamente.")

def ordenar_paises(paises: List[Dict]) -> None:
    while True:
        print("\n--- Ordenar países ---")
        print("1) Nombre (A-Z)")
        print("2) Nombre (Z-A)")
        print("3) Población (ascendente)")
        print("4) Población (descendente)")
        print("5) Superficie (ascendente)")
        print("6) Superficie (descendente)")
        print("7) Volver al menú principal")
        opcion = input("Opción: ").strip()
        if opcion == "1":
            resultado = sorted(paises, key=lambda x: x["nombre"].lower())  # Timsort (Python)
            imprimir_paises(resultado)
        elif opcion == "2":
            resultado = sorted(paises, key=lambda x: x["nombre"].lower(), reverse=True)
            imprimir_paises(resultado)
        elif opcion == "3":
            resultado = sorted(paises, key=lambda x: x["poblacion"])
            imprimir_paises(resultado)
        elif opcion == "4":
            resultado = sorted(paises, key=lambda x: x["poblacion"], reverse=True)
            imprimir_paises(resultado)
        elif opcion == "5":
            resultado = sorted(paises, key=lambda x: x["superficie"])
            imprimir_paises(resultado)
        elif opcion == "6":
            resultado = sorted(paises, key=lambda x: x["superficie"], reverse=True)
            imprimir_paises(resultado)
        elif opcion == "7":
            break
        else:
            msg_error("Opción inválida. Intente nuevamente.")

def mostrar_estadisticas(paises: List[Dict]) -> None:
    if not paises:
        msg_warning("No hay datos para calcular estadísticas.")
        return
    poblaciones = [p["poblacion"] for p in paises]
    superficies = [p["superficie"] for p in paises]
    max_pob = max(poblaciones)
    min_pob = min(poblaciones)
    pais_max = [p for p in paises if p["poblacion"] == max_pob][0]["nombre"]
    pais_min = [p for p in paises if p["poblacion"] == min_pob][0]["nombre"]
    prom_pob = sum(poblaciones) / len(poblaciones)
    prom_sup = sum(superficies) / len(superficies)
    conteo_cont = {}
    for p in paises:
        cont = p["continente"]
        conteo_cont[cont] = conteo_cont.get(cont, 0) + 1
    print("\n--- Estadísticas ---")
    msg_info(f"País con mayor población: {pais_max} ({max_pob:,})")
    msg_info(f"País con menor población: {pais_min} ({min_pob:,})")
    msg_info(f"Promedio de población: {prom_pob:,.2f}")
    msg_info(f"Promedio de superficie: {prom_sup:,.2f} km²")
    print("\nCantidad de países por continente:")
    for cont, cnt in conteo_cont.items():
        print(f"  {cont}: {cnt}")

def existe_pais(paises: List[Dict], nombre: str) -> bool:
    return any(p["nombre"].lower() == nombre.lower() for p in paises)

def agregar_pais(paises: List[Dict]) -> None:
    print("\n--- Agregar país ---")
    nombre = pedir_texto_no_vacio("Nombre del país: ", allow_digits=False)
    if existe_pais(paises, nombre):
        msg_error("Ya existe un país con ese nombre. Operación cancelada.")
        return
    poblacion = pedir_entero("Población (enteros): ")
    superficie = pedir_entero("Superficie en km² (enteros): ")
    continente = pedir_texto_no_vacio("Continente: ", allow_digits=False)
    nuevo = {
        "nombre": nombre,
        "poblacion": poblacion,
        "superficie": superficie,
        "continente": continente
    }
    paises.append(nuevo)
    # Guardado automático tras alta
    if save_paises(paises, CSV_FILE):
        msg_success(f"País '{nombre}' agregado y guardado correctamente.")
    else:
        msg_warning(f"País '{nombre}' agregado en memoria pero NO pudo guardarse en disco.")

def editar_pais(paises: List[Dict]) -> None:
    print("\n--- Editar país ---")
    if not paises:
        msg_warning("No hay países cargados para editar.")
        return
    nombre = pedir_texto_no_vacio("Ingrese el nombre exacto del país a editar: ", allow_digits=False)
    idx = next((i for i, p in enumerate(paises) if p["nombre"].lower() == nombre.lower()), None)
    if idx is None:
        msg_error("No se encontró un país con ese nombre.")
        return
    pais = paises[idx]
    print("Dejar vacío y presionar Enter para mantener el valor actual.")
    nuevo_nombre = input(f"Nombre [{pais['nombre']}]: ").strip()
    if nuevo_nombre:
        if nuevo_nombre.lower() != pais['nombre'].lower() and existe_pais(paises, nuevo_nombre):
            msg_error("Error: ya existe otro país con ese nombre. Cambio de nombre cancelado.")
        else:
            pais['nombre'] = nuevo_nombre
    entrada_pob = input(f"Población [{pais['poblacion']}]: ").strip()
    if entrada_pob:
        ok, val = validar_entero(entrada_pob)
        if ok:
            pais['poblacion'] = val
        else:
            msg_warning("Población inválida. Se mantiene el valor anterior.")
    entrada_sup = input(f"Superficie [{pais['superficie']}]: ").strip()
    if entrada_sup:
        ok, val = validar_entero(entrada_sup)
        if ok:
            pais['superficie'] = val
        else:
            msg_warning("Superficie inválida. Se mantiene el valor anterior.")
    entrada_cont = input(f"Continente [{pais['continente']}]: ").strip()
    if entrada_cont:
        pais['continente'] = entrada_cont
    paises[idx] = pais
    # Guardado automático tras edición
    if save_paises(paises, CSV_FILE):
        msg_success(f"País '{pais['nombre']}' editado y guardado correctamente.")
    else:
        msg_warning(f"Edición de '{pais['nombre']}' realizada en memoria pero NO pudo guardarse en disco.")

# ---------------------- Main loop ---------------------- #

def main() -> None:
    paises = load_paises(CSV_FILE)

    # Si querés crear el CSV de ejemplo, descomentar la línea siguiente una sola vez y ejecutar.
    # crear_csv_ejemplo(CSV_FILE)

    while True:
        mostrar_menu()
        opcion = input("Seleccione una opción (1-9): ").strip()
        if opcion == "1":
            buscar_pais(paises)
        elif opcion == "2":
            menu_filtrar(paises)
        elif opcion == "3":
            ordenar_paises(paises)
        elif opcion == "4":
            mostrar_estadisticas(paises)
        elif opcion == "5":
            agregar_pais(paises)
        elif opcion == "6":
            editar_pais(paises)
        elif opcion == "7":
            # Guardar y salir
            if save_paises(paises, CSV_FILE):
                msg_success(f"Datos guardados en '{CSV_FILE}'. Saliendo...")
            else:
                msg_error("Error al guardar. Saliendo sin confirmar guardado.")
            break
        elif opcion == "8":
            confirm = input("¿Seguro que desea salir sin guardar? (s/n): ").strip().lower()
            if confirm == "s":
                msg_info("Saliendo sin guardar cambios.")
                break
        elif opcion == "9":
            if os.path.exists(CSV_FILE):
                msg_warning(f"El archivo '{CSV_FILE}' ya existe. Si lo sobreescribe, se perderán datos actuales.")
                resp = input("Desea sobreescribirlo con el CSV de ejemplo? (s/n): ").strip().lower()
                if resp != "s":
                    msg_info("Operación cancelada.")
                    continue
            crear_csv_ejemplo(CSV_FILE)
            # recargar datos
            paises = load_paises(CSV_FILE)
        else:
            msg_error("Opción inválida. Ingrese un número del 1 al 9.")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        msg_info("\nInterrupción por teclado recibida. Saliendo...")
        sys.exit(0)

